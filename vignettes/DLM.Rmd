---
title: "DLM"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{DLM}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  message = FALSE,
  warning = FALSE,
  comment = "#>"
)
```

```{r setup}
library(jonnylaw)
library(dlm)
library(dplyr)
library(tidyr)
library(ggplot2)
theme_set(theme_minimal())
```

A general Dynamic linear model is given by

$$\begin{aligned}
Y_t &= F_t\theta_t + v_t, &v_t &\sim \mathcal{N}(0, V_t), \\
\theta_t &= G_t\theta_{t-1} + w_t, &w_t &\sim \mathcal{N}(0, W_t), \\
\theta_0 &\sim \mathcal(m_0, C_0).
\end{aligned}$$

Where $Y_t$ is a $p \times 1$ vector of observations, $F_t$ is a $p \times d$ observation matrix which is typically known and transforms the latent process to the observations. $\theta_t$ is the unobserved latent process of interest at time $t$, it is a $d \times 1$ vector. $V_t$ is the $p \times p$ observation variance matrix typically taken to be diagonal. $G_t$ is the matrix controlling the advance of the latent-state, $W_t$ is the $d \times d$ process noise matrix. $\theta_0$ is the initial state. The latent state is a first order Markov chain and the observations are conditionally independent given the latent state. This allows the Kalman Filter to be used to determine the posterior distribution of the latent state of this model.

## Simulate from a random DLM

Using the `dlm` R package, simulate a random DLM with observation dimension `m = 3` and latent state dimension `p = 3` with `nobs = 100`.

```{r generate-model}
set.seed(123)
model <- dlmRandom(m = 3, p = 3)
model$V <- diag(diag(model$V))
model$W <- diag(diag(model$W))
```

We can then simulate data from the model

```{r simulate-data}
sims <- dlmForecast(model, sampleNew = 100)
state <- matrix(unlist(sims$newStates), ncol = 3)
obs <- matrix(unlist(sims$newObs), ncol = 3)
```

```{r plot-observations}
obs %>% 
  tibble::as_tibble() %>% 
  mutate(time = row_number()) %>% 
  pivot_longer(-time, names_to = "variable", values_to = "value") %>% 
  ggplot(aes(x = time, y = value, colour = variable)) +
  geom_line() +
  facet_wrap(~variable, ncol = 1)
```

Then the C++ implementation of the Kalman Filter can be carried out using the Random DLM.

```{r kalman-filter}
filtered <-
  dlm_kalman_filter(t(obs), model$FF, model$GG, model$V, model$W, model$m0, model$C0)
```

The output `filtered` is an S3 object with class `filtered` - this allows us to define behaviour for generic functions such as `plot` and `summary`. `summary` returns a table containing the one-step forecast, upper and lower 90% probability intervals and the associated observation.

```{r}
summary(filtered)
```

`plot` shows the one-step predictive mean and 90% probability intervals with the observations in red.

```{r plot-filtered}
plot(filtered)
```

Plot the simulated state and the filtered mean.

```{r plot-filtered-sim, echo=FALSE}
d <- ncol(model$FF)
filtered_state <-
  filtered$mt[,-1] %>% t() %>% 
  as_tibble() 
names(filtered_state) <- paste0(rep("state", time = d), seq_len(d))

filtered_state <- filtered_state %>% 
  mutate(time = row_number()) %>% 
  pivot_longer(-time, names_to = "variable", values_to = "filtered")

state_df <- state %>% 
  tibble::as_tibble()
names(state_df) <- paste0(rep("state", time = d), seq_len(d))

state_df <- state_df %>% 
  mutate(time = row_number()) %>% 
  pivot_longer(-time, names_to = "variable", values_to = "state")

filtered_state %>% 
  inner_join(state_df, by = c("time", "variable")) %>% 
  pivot_longer(c(state, filtered), names_to = "state", values_to = "value") %>% 
  ggplot() +
    geom_line(aes(x = time, y = value, colour = state)) +
    facet_wrap(~variable, ncol = 1)
```

## Gibbs Sampling using FFBS

Gibbs sampling is used to determine the posterior distribution of the observation and system noise covariance matrices using the `dlm` `R` library. The `dlm` library has an implementation of Forward Filtering Backward Sampling (FFBS) based on the singular value decomposition of the process-noise covariance matrix - this is a very stable algorithm however it is implemented in R and hence is relatively slow (compared to compiled languages). This package contains a re-written version of the FFBS algorithm using [RCpp](http://rcpp.org) and the [Joseph form covariance update](https://en.wikipedia.org/wiki/Kalman_filter#Derivations).

The following benchmark shows the speed difference from the implementation of the FFBS algorithm in the `dlm` package and the implementation in `Rcpp`. The results plot below shows the running time across 50 iterations of the FFBS algorithm. 

```{r}
benchmark_ffbs <-
  bench::mark(
    "R" = dlmBSample(dlmFilter(obs, model)),
    "Rcpp" = dlm_ffbs(t(obs), model),
    check = FALSE,
    iterations = 50
  )
plot(benchmark_ffbs)
```

The median execution time for the non-optimised R algorithm is `r benchmark_ffbs[1, "median"]` and the median execution time for the Rcpp implementation is `r benchmark_ffbs[2, "median"]`.

Sampling diagonal observation and system noise matrices using the inverse Gamma distribution.

```{r gibbs-sampling, cache=TRUE, eval=FALSE}
chains <-
  dlm_gibbs(
    ys = t(obs),
    mod = model,
    shape_v = 3,
    rate_v = 3,
    shape_w = 3,
    rate_w = 3,
    iters = 1e4,
    progress = TRUE
  )
```

```{r plot-observation-diagnostics, echo=FALSE, eval=FALSE}
actual_values <- tibble(
  parameter = c(paste0("w", seq_len(nrow(model$W))), paste0("v", seq_len(nrow(model$V)))),
  actual_value = c(diag(model$W), diag(model$V)))

chains %>% 
  select(contains("v"), iteration) %>% 
  pivot_longer(-iteration, names_to = "parameter", values_to = "value") %>% 
  plot_diagnostics_sim(actual_values)
```

```{r plot-system-diagnostics, echo=FALSE, eval=FALSE}
chains %>% 
  select(contains("w"), iteration) %>% 
  pivot_longer(-iteration, names_to = "parameter", values_to = "value") %>% 
  plot_diagnostics_sim(actual_values)
```
